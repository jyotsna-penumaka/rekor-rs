/*
 * Rekor
 *
 * Rekor is a cryptographically secure, immutable transparency log for signed software releases.
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 * Generated by: https://openapi-generator.tech
 */

/// Rekord : Rekord object


use url::Url;

#[derive(Clone,Debug, PartialEq, Serialize, Deserialize)]
pub struct Rekord {
    #[serde(rename = "kind")]
    pub kind: String,
    #[serde(rename = "apiVersion")]
    pub api_version: String,
    #[serde(rename = "spec")]
    pub spec: Spec,
}

impl Rekord {
    /// Rekord object
    pub fn new(kind: String, api_version: String, spec: Spec) -> Rekord {
        Rekord {
            kind,
            api_version,
            spec,
        }
    }
}

/// Stores the Signature and Data struct
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Spec {
    signature: Signature,
    data: Data,
}

impl Spec {
    pub fn new(signature: Signature, data: Data) -> Spec {
        Spec { signature, data }
    }
}

/// Stores the signature format, signature of the artifact and the PublicKey struct
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Signature {
    format: String,
    content: String,
    public_key: PublicKey,
}

impl Signature {
    pub fn new(format: String, content: String, public_key: PublicKey) -> Signature {
        Signature {
            format,
            content,
            public_key,
        }
    }
}

/// Stores the public key used to sign the artifact
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct PublicKey {
    content: String,
}

impl PublicKey {
    pub fn new(content: String) -> PublicKey {
        PublicKey { content }
    }
}

// get rid of the default
// change url type from string -> URL type
/// Stores the Hash struct and location of the file
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Data {
    hash: Hash,
    url: Url,
}

// use &str instead, build a URL from it
impl Data {
    pub fn new(hash: Hash, url: Url) -> Data {
        Data { hash, url }
    }
}

/// Stores the algorithm used to hash the artifact and the value of the hash
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Hash {
    algorithm: String,
    value: String,
}

// implement the default trait
// Hash would be an enum or string (decide!)
// make the feilds private, and within the new method in Hash just validate if the algorithm is what you expect
// a new method, from_sha256 hardcodes algorithm as sha256
// get rid of hash builder
// value: vec<u8> instead of a string, because you will read it from a file
impl Hash {
    pub fn new(algorithm: String, value: String) -> Hash {
        Hash {
            algorithm,
            value,
        }
    }
}

